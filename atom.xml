<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>banban&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/0571ff454db1ab343c858f10a02ffebe</icon>
  <subtitle>Learn Anything, Anytime, Anywhere~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://banbanpeppa.github.io/"/>
  <updated>2018-09-26T12:07:17.640Z</updated>
  <id>https://banbanpeppa.github.io/</id>
  
  <author>
    <name>Chen Zhi Ling</name>
    <email>wisteriasomnus@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>超级账本使用fabric-sample</title>
    <link href="https://banbanpeppa.github.io/2018/09/26/hyperledger/fabric-first-network/"/>
    <id>https://banbanpeppa.github.io/2018/09/26/hyperledger/fabric-first-network/</id>
    <published>2018-09-26T02:32:00.000Z</published>
    <updated>2018-09-26T12:07:17.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li>环境基于Ubuntu16.04</li><li>Fabric version = 1.2.0</li></ul><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><pre><code>apt-get install docker.io -y</code></pre><h3 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h3><pre><code>apt-get install -y python-pip python-setuptoolspip install --upgrade pippip install docker-composecurl -L --fail https://github.com/docker/compose/releases/download/1.19.0/run.sh -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-composedocker-compose --version</code></pre><h3 id="安装go"><a href="#安装go" class="headerlink" title="安装go"></a>安装go</h3><pre><code>wget http://p22qphkhy.bkt.clouddn.com/go1.10.linux-amd64.tar.gztar -C /usr/local -xzf go1.10.linux-amd64.tar.gzvim /etc/profile    export GOROOT=/usr/local/go    export PATH=$PATH:$GOROOT/bin    export GOPATH=/opt/gopathsource  /etc/profilego version</code></pre><h2 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h2><p>创建<code>fabric-sample</code>项目的根路径，由于<code>fabric</code>的很多example项目基于Golang开发，因此建议是将Go路径设置在${GOPATH}，然后创建如下路径</p><pre><code>mkdir -p ${GOPATH}/src/github.com/hyperledger/ &amp;&amp; cd ${GOPATH}/src/github.com/hyperledger/</code></pre><p>克隆fabric-sample项目</p><pre><code>git clone https://github.com/hyperledger/fabric-samples.git &amp;&amp; cd fabric-samples/</code></pre><h2 id="安装fabric-tools"><a href="#安装fabric-tools" class="headerlink" title="安装fabric-tools"></a>安装fabric-tools</h2><p>进入到<code>fabric-sample</code>目录下进行fabric-tools的安装</p><pre><code>curl -sSL https://raw.githubusercontent.com/hyperledger/fabric/master/scripts/bootstrap.sh | bash -s 1.2.0</code></pre><p>执行完成之后，fabric-sample下会多出一个bin目录，这个目录下面包含了<code>fabric-tools</code>，可以将这个bin文件夹添加到环境变量中</p><pre><code>vim /etc/profile---export PATH=$GOPATH/src/github.com/hyperledger/fabric-samples/bin:$PATH---</code></pre><h2 id="通过脚本启动fabirc-first-network网络"><a href="#通过脚本启动fabirc-first-network网络" class="headerlink" title="通过脚本启动fabirc-first-network网络"></a>通过脚本启动fabirc-first-network网络</h2><p>通过脚本启动fabric是比较简单的方式，这个fabric网络拓扑是最简单的网络，具体如下图所示</p><p><img src="/images/blockchain/hyperledger/fabric-sample-topology.png" alt="image"></p><p>首先进入到first-network目录下</p><pre><code>cd ./first-network</code></pre><h3 id="生成认证密钥"><a href="#生成认证密钥" class="headerlink" title="生成认证密钥"></a>生成认证密钥</h3><p>生成fabric-sample需要的所有的认证和密钥，以方便之后启动整个网络的时候使用</p><pre><code>echo y | ./byfn.sh -m generate</code></pre><p>执行结果如下</p><pre><code>Generating certs and genesis block for channel &#39;mychannel&#39; with CLI timeout of &#39;10&#39; seconds and CLI delay of &#39;3&#39; secondsproceeding .../opt/go/src/github.com/hyperledger/fabric-samples/bin/cryptogen############################################################### Generate certificates using cryptogen tool ###################################################################+ cryptogen generate --config=./crypto-config.yamlorg1.example.comorg2.example.com+ res=0+ set +x/opt/go/src/github.com/hyperledger/fabric-samples/bin/configtxgen###################################################################  Generating Orderer Genesis block ########################################################################+ configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block2018-09-26 10:59:32.833 HKT [common/tools/configtxgen] main -&gt; WARN 001 Omitting the channel ID for configtxgen is deprecated.  Explicitly passing the channel ID will be required in the future, defaulting to &#39;testchainid&#39;.2018-09-26 10:59:32.833 HKT [common/tools/configtxgen] main -&gt; INFO 002 Loading configuration2018-09-26 10:59:32.839 HKT [common/tools/configtxgen/encoder] NewChannelGroup -&gt; WARN 003 Default policy emission is deprecated, please include policy specificiations for the channel group in configtx.yaml2018-09-26 10:59:32.840 HKT [common/tools/configtxgen/encoder] NewOrdererGroup -&gt; WARN 004 Default policy emission is deprecated, please include policy specificiations for the orderer group in configtx.yaml2018-09-26 10:59:32.840 HKT [common/tools/configtxgen/encoder] NewOrdererOrgGroup -&gt; WARN 005 Default policy emission is deprecated, please include policy specificiations for the orderer org group OrdererOrg in configtx.yaml2018-09-26 10:59:32.840 HKT [msp] getMspConfig -&gt; INFO 006 Loading NodeOUs2018-09-26 10:59:32.840 HKT [common/tools/configtxgen/encoder] NewOrdererOrgGroup -&gt; WARN 007 Default policy emission is deprecated, please include policy specificiations for the orderer org group Org1MSP in configtx.yaml2018-09-26 10:59:32.840 HKT [msp] getMspConfig -&gt; INFO 008 Loading NodeOUs2018-09-26 10:59:32.840 HKT [common/tools/configtxgen/encoder] NewOrdererOrgGroup -&gt; WARN 009 Default policy emission is deprecated, please include policy specificiations for the orderer org group Org2MSP in configtx.yaml2018-09-26 10:59:32.841 HKT [common/tools/configtxgen] doOutputBlock -&gt; INFO 00a Generating genesis block2018-09-26 10:59:32.841 HKT [common/tools/configtxgen] doOutputBlock -&gt; INFO 00b Writing genesis block+ res=0+ set +x#################################################################### Generating channel configuration transaction &#39;channel.tx&#39; ####################################################################+ configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID mychannel2018-09-26 10:59:32.875 HKT [common/tools/configtxgen] main -&gt; INFO 001 Loading configuration2018-09-26 10:59:32.882 HKT [common/tools/configtxgen] doOutputChannelCreateTx -&gt; INFO 002 Generating new channel configtx2018-09-26 10:59:32.882 HKT [common/tools/configtxgen/encoder] NewApplicationGroup -&gt; WARN 003 Default policy emission is deprecated, please include policy specificiations for the application group in configtx.yaml2018-09-26 10:59:32.882 HKT [msp] getMspConfig -&gt; INFO 004 Loading NodeOUs2018-09-26 10:59:32.882 HKT [common/tools/configtxgen/encoder] NewApplicationOrgGroup -&gt; WARN 005 Default policy emission is deprecated, please include policy specificiations for the application org group Org1MSP in configtx.yaml2018-09-26 10:59:32.882 HKT [msp] getMspConfig -&gt; INFO 006 Loading NodeOUs2018-09-26 10:59:32.882 HKT [common/tools/configtxgen/encoder] NewApplicationOrgGroup -&gt; WARN 007 Default policy emission is deprecated, please include policy specificiations for the application org group Org2MSP in configtx.yaml2018-09-26 10:59:32.883 HKT [common/tools/configtxgen] doOutputChannelCreateTx -&gt; INFO 008 Writing new channel tx+ res=0+ set +x########################################################################    Generating anchor peer update for Org1MSP   ###########################################################################+ configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP2018-09-26 10:59:32.917 HKT [common/tools/configtxgen] main -&gt; INFO 001 Loading configuration2018-09-26 10:59:32.924 HKT [common/tools/configtxgen] doOutputAnchorPeersUpdate -&gt; INFO 002 Generating anchor peer update2018-09-26 10:59:32.924 HKT [common/tools/configtxgen] doOutputAnchorPeersUpdate -&gt; INFO 003 Writing anchor peer update+ res=0+ set +x########################################################################    Generating anchor peer update for Org2MSP   ###########################################################################+ configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID mychannel -asOrg Org2MSP2018-09-26 10:59:32.958 HKT [common/tools/configtxgen] main -&gt; INFO 001 Loading configuration2018-09-26 10:59:32.964 HKT [common/tools/configtxgen] doOutputAnchorPeersUpdate -&gt; INFO 002 Generating anchor peer update2018-09-26 10:59:32.965 HKT [common/tools/configtxgen] doOutputAnchorPeersUpdate -&gt; INFO 003 Writing anchor peer update+ res=0+ set +x</code></pre><h3 id="启动fabric-sample网络"><a href="#启动fabric-sample网络" class="headerlink" title="启动fabric-sample网络"></a>启动fabric-sample网络</h3><p>启动fabric-sample网络</p><pre><code>echo y | ./byfn.sh -m up</code></pre><blockquote><p>如果想要使用nodejs语言或者java编写的智能合约，可以使用 -l 标志指定智能合约语言<br>不指定默认使用Golang<br><code>echo y | ./byfn.sh -m up -l node</code><br><code>echo y | ./byfn.sh -m up -l java</code> java在版本1.2.0以前还属于测试实验阶段，不建议使用</p></blockquote><p>执行成功结果</p><pre><code>Installing chaincode on peer1.org2...+ peer chaincode install -n mycc -v 1.0 -l golang -p github.com/chaincode/chaincode_example02/go/+ res=0+ set +x2018-09-26 03:00:38.660 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc2018-09-26 03:00:38.660 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc2018-09-26 03:00:38.810 UTC [chaincodeCmd] install -&gt; INFO 003 Installed remotely response:&lt;status:200 payload:&quot;OK&quot; &gt; ===================== Chaincode is installed on peer1.org2 ===================== Querying chaincode on peer1.org2...===================== Querying on peer1.org2 on channel &#39;mychannel&#39;... ===================== + peer chaincode query -C mychannel -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39;Attempting to Query peer1.org2 ...3 secs+ res=0+ set +x90===================== Query successful on peer1.org2 on channel &#39;mychannel&#39; ===================== ========= All GOOD, BYFN execution completed ===========  _____   _   _   ____   | ____| | \ | | |  _ \  |  _|   |  \| | | | | | | |___  | |\  | | |_| | |_____| |_| \_| |____/  </code></pre><p>执行</p><pre><code>docker ps -aCONTAINER ID        IMAGE                                                                                                  COMMAND                  CREATED             STATUS              PORTS                                              NAMES4b4f8645851b        dev-peer1.org2.example.com-mycc-1.0-26c2ef32838554aac4f7ad6f100aca865e87959c9a126e86d764c8d01f8346ab   &quot;chaincode -peer.add…&quot;   13 minutes ago      Up 13 minutes                                                          dev-peer1.org2.example.com-mycc-1.0c7c9b42dabb5        dev-peer0.org1.example.com-mycc-1.0-384f11f484b9302df90b453200cfb25174305fce8f53f4e94d45ee3b6cab0ce9   &quot;chaincode -peer.add…&quot;   14 minutes ago      Up 14 minutes                                                          dev-peer0.org1.example.com-mycc-1.060a0739363b8        dev-peer0.org2.example.com-mycc-1.0-15b571b3ce849066b7ec74497da3b27e54e0df1345daff3951b94245ce09c42b   &quot;chaincode -peer.add…&quot;   14 minutes ago      Up 14 minutes                                                          dev-peer0.org2.example.com-mycc-1.0d37d3e69b469        hyperledger/fabric-tools:latest                                                                        &quot;/bin/bash&quot;              14 minutes ago      Up 14 minutes                                                          cli5fa3f4446d13        hyperledger/fabric-orderer:latest                                                                      &quot;orderer&quot;                15 minutes ago      Up 14 minutes       0.0.0.0:7050-&gt;7050/tcp                             orderer.example.combc307a3fb4bd        hyperledger/fabric-peer:latest                                                                         &quot;peer node start&quot;        15 minutes ago      Up 14 minutes       0.0.0.0:8051-&gt;7051/tcp, 0.0.0.0:8053-&gt;7053/tcp     peer1.org1.example.com220a1b0c964e        hyperledger/fabric-peer:latest                                                                         &quot;peer node start&quot;        15 minutes ago      Up 14 minutes       0.0.0.0:7051-&gt;7051/tcp, 0.0.0.0:7053-&gt;7053/tcp     peer0.org1.example.com3e3a078b25bc        hyperledger/fabric-peer:latest                                                                         &quot;peer node start&quot;        15 minutes ago      Up 14 minutes       0.0.0.0:9051-&gt;7051/tcp, 0.0.0.0:9053-&gt;7053/tcp     peer0.org2.example.com5c02ec9c1b24        hyperledger/fabric-peer:latest                                                                         &quot;peer node start&quot;        15 minutes ago      Up 14 minutes       0.0.0.0:10051-&gt;7051/tcp, 0.0.0.0:10053-&gt;7053/tcp   peer1.org2.example.com</code></pre><p>会看到有一个排序节点<code>orderer.example.com</code>，2个组织，4个节点<code>peer0.org1.example.com</code>、<code>peer0.org2.example.com</code>、<code>peer1.org1.example.com</code>、<code>peer1.org2.example.com</code></p><p>其中<code>cli</code>容器是<code>fabric-first-network</code>的一个客户端, 可以直接进入到<code>cli</code>进行操作</p><pre><code>docker exec -it cli sh</code></pre><blockquote><p>使用bash也可以</p></blockquote><pre><code>peer channel list2018-09-26 03:34:36.783 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initializedChannels peers has joined: mychannel</code></pre><p>会看到有一个channel名为<code>mychannel</code>，因此将这个加到环境变量中</p><pre><code>export CHANNEL_NAME=mychannel</code></pre><p>同时添加下列环境变量</p><pre><code>export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspexport CORE_PEER_ADDRESS=peer0.org1.example.com:7051export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</code></pre><h3 id="查询链上信息"><a href="#查询链上信息" class="headerlink" title="查询链上信息"></a>查询链上信息</h3><p>查询<code>a</code>账户里面的值</p><pre><code>peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39;90</code></pre><p>这个<code>a</code>账户原本是有100的，在部署网络的时候执行了一次转账到<code>b</code>账户，因此变成了90，可以查询<code>b</code>的数值得到</p><pre><code>peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;b&quot;]}&#39; 210</code></pre><p>这个信息具体可以通过如下打日志的方式查看，先退出<code>bash</code>或者<code>sh</code>，然后在宿主机执行</p><pre><code>docker logs dev-peer0.org1.example.com-mycc-1.0ex02 InvokeQuery Response:{&quot;Name&quot;:&quot;a&quot;,&quot;Amount&quot;:&quot;100&quot;}ex02 InvokeAval = 90, Bval = 210ex02 InvokeQuery Response:{&quot;Name&quot;:&quot;a&quot;,&quot;Amount&quot;:&quot;90&quot;}ex02 InvokeQuery Response:{&quot;Name&quot;:&quot;a&quot;,&quot;Amount&quot;:&quot;90&quot;}ex02 InvokeQuery Response:{&quot;Name&quot;:&quot;b&quot;,&quot;Amount&quot;:&quot;210&quot;}</code></pre><pre><code>docker logs dev-peer0.org2.example.com-mycc-1.0ex02 InitAval = 100, Bval = 200ex02 InvokeAval = 90, Bval = 21</code></pre><pre><code>docker logs dev-peer1.org2.example.com-mycc-1.0ex02 InvokeQuery Response:{&quot;Name&quot;:&quot;a&quot;,&quot;Amount&quot;:&quot;90&quot;}</code></pre><h3 id="关闭fabric-sample网络"><a href="#关闭fabric-sample网络" class="headerlink" title="关闭fabric-sample网络"></a>关闭fabric-sample网络</h3><p>如果在启动网络的过程中出现了错误或者失败，则可以关闭网络重来，或者说实验完之后想删除整个实验网络，则执行如下命令，这个脚本执行会会将对应的docker容器删除，通过脚本进行实验也只是为了对这个网络的启动和关闭有一个完整的体验和感知，之后我们需要通过一些步骤来启动一个完整功能的网络</p><pre><code>echo y | ./byfn.sh -m down</code></pre><h2 id="手动启动first-network"><a href="#手动启动first-network" class="headerlink" title="手动启动first-network"></a>手动启动first-network</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;环境基于Ubuntu16.04&lt;/li&gt;
&lt;li&gt;Fabric version = 1.2.0&lt;/li&gt;
&lt;/u
      
    
    </summary>
    
    
      <category term="Blockchain" scheme="https://banbanpeppa.github.io/tags/Blockchain/"/>
    
      <category term="Hyperledger" scheme="https://banbanpeppa.github.io/tags/Hyperledger/"/>
    
      <category term="Fabric" scheme="https://banbanpeppa.github.io/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>Docker 安装</title>
    <link href="https://banbanpeppa.github.io/2018/09/25/docker/docker-installation/"/>
    <id>https://banbanpeppa.github.io/2018/09/25/docker/docker-installation/</id>
    <published>2018-09-25T05:00:00.000Z</published>
    <updated>2018-09-26T01:51:27.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Debian9"><a href="#Debian9" class="headerlink" title="Debian9"></a>Debian9</h2><h3 id="移除旧的docker相关软件"><a href="#移除旧的docker相关软件" class="headerlink" title="移除旧的docker相关软件"></a>移除旧的docker相关软件</h3><pre><code>$ sudo apt-get remove docker docker-engine docker.io</code></pre><pre><code>$ sudo apt-get update</code></pre><h3 id="安装基本软件"><a href="#安装基本软件" class="headerlink" title="安装基本软件"></a>安装基本软件</h3><pre><code>$ sudo apt-get install -y \     apt-transport-https \     ca-certificates \     curl \     gnupg2 \     software-properties-common</code></pre><h3 id="添加docker安装源"><a href="#添加docker安装源" class="headerlink" title="添加docker安装源"></a>添加docker安装源</h3><pre><code>$ curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -</code></pre><pre><code>$ sudo apt-key fingerprint 0EBFCD88</code></pre><pre><code>$ sudo add-apt-repository \   &quot;deb [arch=amd64] https://download.docker.com/linux/debian \   $(lsb_release -cs) \   stable&quot;</code></pre><pre><code>$ sudo apt-get update</code></pre><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>$ sudo apt-get install -y docker-ce</code></pre><h3 id="更改国内源"><a href="#更改国内源" class="headerlink" title="更改国内源"></a>更改国内源</h3><pre><code>vim /etc/default/docker</code></pre><p>更改内容</p><pre><code>DOCKER_OPTS=&quot;--dns 114.114.114.114 --graph=/home/chenzhiling/docker --registry-mirror=https://docker.mirrors.ustc.edu.cn/&quot;</code></pre><pre><code>$ sudo service docker restart</code></pre><h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><pre><code>apt-get updateapt-get install -y apt-transport-https ca-certificates curl software-properties-commoncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -add-apt-repository &quot;deb https://download.docker.com/linux/$(. /etc/os-release; echo &quot;$ID&quot;) $(lsb_release -cs) stable&quot;apt-get update &amp;&amp; apt-get install -y docker-ce=$(apt-cache madison docker-ce | grep 17.03 | head -1 | awk &#39;{print $3}&#39;)</code></pre><h2 id="Deepin"><a href="#Deepin" class="headerlink" title="Deepin"></a>Deepin</h2><pre><code>apt-get updateapt-get install -y docker.iosystemctl enable docker.service</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Debian9&quot;&gt;&lt;a href=&quot;#Debian9&quot; class=&quot;headerlink&quot; title=&quot;Debian9&quot;&gt;&lt;/a&gt;Debian9&lt;/h2&gt;&lt;h3 id=&quot;移除旧的docker相关软件&quot;&gt;&lt;a href=&quot;#移除旧的docker相关软件&quot; cla
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://banbanpeppa.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 集群安装(使用kubeadm)</title>
    <link href="https://banbanpeppa.github.io/2018/09/25/kubernetes/installation/"/>
    <id>https://banbanpeppa.github.io/2018/09/25/kubernetes/installation/</id>
    <published>2018-09-25T04:00:00.000Z</published>
    <updated>2018-09-25T15:15:37.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><pre><code>Debian9: Debian 4.9.65-3+deb9u1 (2017-12-23) x86_64 GNU/Linux</code></pre><h3 id="服务器信息"><a href="#服务器信息" class="headerlink" title="服务器信息"></a>服务器信息</h3><table><thead><tr><th>hostname</th><th>IP</th></tr></thead><tbody><tr><td>master-node</td><td>10.82.45.41</td></tr><tr><td>minion-node-1</td><td>10.82.45.42</td></tr><tr><td>minion-node-2</td><td>10.82.45.43</td></tr></tbody></table><h3 id="预装软件"><a href="#预装软件" class="headerlink" title="预装软件"></a>预装软件</h3><ol><li><p>安装systemd</p><p> <code>systemctl</code>工具之所以重要，是因为<code>systemctl</code>服务管理工具是之后Kubernetes安装过程中，其要判断别的服务是否启动的方式，如<code>kubeadm</code>在初始化集群的时候会判断<code>kubelet</code>服务是否启动，其主要通过 <code>systemctl</code> 方式判断，如果<code>systemd</code>工具不能使用，会导致失败(除非是强行抑制这个错误，但是难保证后续不出错)</p><p> 如果确定systemctl工具没有安装,可以按照如下安装</p><pre><code> apt-get update apt-get -y install systemd</code></pre><p> 如果已经安装好之后发现</p><pre><code> systemctl status xxx.service</code></pre><p> 之后会出现如下错误</p><pre><code> Failed to get properties: No such interface &#39;&#39;</code></pre><p> 则说明系统默认并没有采用systemd来管理服务，这个时候需要修改系统内核参数</p><p> 编辑<code>/etc/default/grub</code>文件，找到GRUB_CMDLINE_LINUX参数，这个参数的值是一个键值对形式的参数集合，在这个参数内添加如下内容</p><pre><code> GRUB_CMDLINE_LINUX=&quot; ... init=/bin/systemd&quot;</code></pre><p> 保存之后，更新grub来更新内核参数</p><pre><code> update-grub</code></pre><p> 重启系统</p><pre><code> reboot</code></pre></li><li><p>关闭swap</p><p> Kubernetes 1.8开始要求关闭系统的Swap，如果不关闭，默认配置下kubelet将无法启动。可以通过kubelet的启动参数–fail-swap-on=false更改这个限制。 我们这里关闭系统的Swap:</p><pre><code> swapoff -a</code></pre><p> 修改 /etc/fstab 文件，注释掉 SWAP 的自动挂载，使用free -m确认swap已经关闭</p><pre><code> 注意：生产环境下,还是建议不要关闭swap,通过--fail-swap-on=false参数来达到目的</code></pre></li><li><p>安装<a href="https://github.com/kubernetes-incubator/cri-tools" target="_blank" rel="noopener">cri-tools</a></p><p> CLI and validation tools for Kubelet Container Runtime Interface</p><p> kubelet工具想要正常运行，需要安装该工具</p><p> 打开<a href="https://github.com/kubernetes-incubator/cri-tools/releases" target="_blank" rel="noopener">release</a>找到符合要求的版本(跟需要安装的Kubernetes对应)</p><p> 这边安装的版本选择v1.11.0</p><pre><code> wget https://github.com/kubernetes-incubator/cri-tools/releases/download/v1.11.0/crictl-v1.11.0-linux-amd64.tar.gz \ &amp;&amp; tar zxvf crictl-v1.11.0-linux-amd64.tar.gz \ &amp;&amp; mv crictl /usr/bin</code></pre></li><li><p>安装docker-ce</p><pre><code> apt-get remove docker docker-engine docker.io apt-get update apt-get install \     apt-transport-https \     ca-certificates \     curl \     gnupg2 \     software-properties-common curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add - apt-key fingerprint 0EBFCD88 add-apt-repository \     &quot;deb [arch=amd64] https://download.docker.com/linux/debian \         $(lsb_release -cs) \     stable&quot; apt-get update apt-get install docker-ce</code></pre></li><li><p>安装cni工具(K8s网络需要使用)</p><pre><code> CNI_VERSION=v0.6.0 \ &amp;&amp; mkdir -p /opt/cni/bin \ &amp;&amp; curl -L &quot;https://github.com/containernetworking/plugins/releases/download/${CNI_VERSION}/cni-plugins-amd64-${CNI_VERSION}.tgz&quot; | tar -C /opt/cni/bin -xz</code></pre></li><li><p>配置iptables信息</p><pre><code> echo &#39;1&#39; &gt; /proc/sys/net/ipv4/ip_forward echo 1 &gt; /proc/sys/net/bridge/bridge-nf-call-iptables echo 1 &gt; /proc/sys/net/bridge/bridge-nf-call-ip6tables sysctl -p</code></pre></li></ol><h2 id="Kubernetes-v1-11-0安装"><a href="#Kubernetes-v1-11-0安装" class="headerlink" title="Kubernetes v1.11.0安装"></a>Kubernetes v1.11.0安装</h2><h3 id="获取二进制文件"><a href="#获取二进制文件" class="headerlink" title="获取二进制文件"></a>获取二进制文件</h3><p>在<a href="https://github.com/kubernetes/kubernetes" target="_blank" rel="noopener">Kubernetes</a>的github页面找到<a href="https://github.com/kubernetes/kubernetes/releases" target="_blank" rel="noopener">release</a>页，选择版本v1.11.0，点击<a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.11.md#v1110" target="_blank" rel="noopener">CHANGELOG-1.11.md</a>，会看到有包含server/client/node三个角色的Kubernetes的二进制文件,这边只需要下载node的二进制文件，我已经上传到了国内七牛云存储中</p><pre><code>wget http://pbqsx8kpd.bkt.clouddn.com/kubernetes-node-linux-11-amd64.tar.gz \&amp;&amp; tar zxvf kubernetes-node-linux-11-amd64.tar.gz \&amp;&amp; cd kubernetes/node/bin \&amp;&amp; chmod +x kube* \&amp;&amp; cp kubelet kubectl kubeadm /usr/bin \&amp;&amp; cd $HOME</code></pre><h3 id="配置kubelet服务到systemd中"><a href="#配置kubelet服务到systemd中" class="headerlink" title="配置kubelet服务到systemd中"></a>配置kubelet服务到systemd中</h3><pre><code>RELEASE=v1.11.0 \&amp;&amp; curl -sSL &quot;https://raw.githubusercontent.com/kubernetes/kubernetes/${RELEASE}/build/debs/kubelet.service&quot; &gt; /etc/systemd/system/kubelet.service \&amp;&amp; mkdir -p /etc/systemd/system/kubelet.service.d \&amp;&amp; curl -sSL &quot;https://raw.githubusercontent.com/kubernetes/kubernetes/${RELEASE}/build/debs/10-kubeadm.conf&quot; &gt; /etc/systemd/system/kubelet.service.d/10-kubeadm.conf</code></pre><p>重启服务</p><pre><code>systemctl stop kubeletsystemctl daemon reloadsystemctl enable kubeletsystemctl start kubeletsystemctl status kubelet</code></pre><h3 id="提前拉取docker镜像"><a href="#提前拉取docker镜像" class="headerlink" title="提前拉取docker镜像"></a>提前拉取docker镜像</h3><p>由于kubeadm工具默认会去国外谷歌的镜像源拉取k8s安装需要的镜像文件(k8s.gcr.io), 这个时候就需要提前将docker镜像拉取下来之后重新tag，本人已经将镜像放置在netease内部镜像源中,直接按照如下执行即可</p><pre><code>docker pull registry.cn-shenzhen.aliyuncs.com/k8s_gcr_io/kube-scheduler-amd64:v1.11.0 &amp;&amp; \docker pull registry.cn-shenzhen.aliyuncs.com/k8s_gcr_io/kube-controller-manager-amd64:v1.11.0 &amp;&amp; \docker pull registry.cn-shenzhen.aliyuncs.com/k8s_gcr_io/kube-apiserver-amd64:v1.11.0 &amp;&amp; \docker pull registry.cn-shenzhen.aliyuncs.com/k8s_gcr_io/kube-proxy-amd64:v1.11.0 &amp;&amp; \docker pull registry.cn-shenzhen.aliyuncs.com/k8s_gcr_io/coredns:1.1.3 &amp;&amp; \docker pull registry.cn-shenzhen.aliyuncs.com/k8s_gcr_io/etcd-amd64:3.2.18 &amp;&amp; \docker pull registry.cn-shenzhen.aliyuncs.com/k8s_gcr_io/pause-amd64:3.1 &amp;&amp; \docker pull registry.cn-shenzhen.aliyuncs.com/k8s_gcr_io/pause:3.1</code></pre><pre><code>其中有一些镜像是非必需的,本人是因为后续需要为kubeflow提供镜像支撑,因此提前拉取，其中tf_operator、jupyterhub-k8s为非必需镜像</code></pre><p>接下来为各个镜像打tag</p><pre><code>docker tag 0e4a34a3b0e6 k8s.gcr.io/kube-scheduler-amd64:v1.11.0 &amp;&amp; \ docker tag 55b70b420785 k8s.gcr.io/kube-controller-manager-amd64:v1.11.0 &amp;&amp; \ docker tag 1d3d7afd77d1 k8s.gcr.io/kube-proxy-amd64:v1.11.0 &amp;&amp; \ docker tag 214c48e87f58 k8s.gcr.io/kube-apiserver-amd64:v1.11.0 &amp;&amp; \ docker tag b3b94275d97c k8s.gcr.io/coredns:1.1.3 &amp;&amp; \ docker tag b8df3b177be2 k8s.gcr.io/etcd-amd64:3.2.18 &amp;&amp; \ docker tag da86e6ba6ca1 k8s.gcr.io/pause-amd64:3.1 &amp;&amp; \ docker tag da86e6ba6ca1 k8s.gcr.io/pause:3.1</code></pre><h3 id="初始化Master节点"><a href="#初始化Master节点" class="headerlink" title="初始化Master节点"></a>初始化Master节点</h3><pre><code>kubeadm init --kubernetes-version=v1.11.0 --apiserver-advertise-address 10.82.45.41 --pod-network-cidr=10.244.0.0/16 --node-name=master-node</code></pre><p><code>--apiserver-advertise-address</code> 指明用 Master 的哪个 interface 与 Cluster 的其他节点通信。如果 Master 有多个 interface，建议明确指定，如果不指定，kubeadm 会自动选择有默认网关的 interface</p><p><code>--pod-network-cidr</code> 指定 Pod 网络的范围。Kubernetes 支持多种网络方案，而且不同网络方案对 <code>--pod-network-cidr</code> 有自己的要求，这里设置为 <code>10.244.0.0/16</code> 是因为我们将使用 flannel 网络方案，必须设置成这个 CIDR。当然还有其他网络方案，比如 <code>Canal</code></p><p>初始化过程中,经历的主要过程包括</p><p><img src="/images/kube/kubeadm-init.png" alt="image"></p><pre><code>① kubeadm 执行初始化前的检查② 生成 token 和证书 (token查询可以使用 kubeadm token list)③ 生成 KubeConfig 文件，kubelet 需要这个文件与 Master 通信④ 安装 Master 组件，会从 goolge 的 Registry 下载组件的 Docker 镜像，这一步可能会花一些时间，主要取决于网络质量⑤ 安装附加组件 kube-proxy 和 kube-dns⑥ Kubernetes Master 初始化成功⑦ 提示如何配置 kubectl，后面会实践⑧ 提示如何安装 Pod 网络，后面会实践⑨ 提示如何注册其他节点到 Cluster，后面会实践</code></pre><h3 id="配置-kubectl"><a href="#配置-kubectl" class="headerlink" title="配置 kubectl"></a>配置 kubectl</h3><p>kubectl 是管理 Kubernetes Cluster 的命令行工具，前面我们已经在所有的节点安装了 kubectl。Master 初始化完成后需要做一些配置工作，然后 kubectl 就能使用了</p><p>依照 kubeadm init 输出的第 ⑦ 步提示，推荐用 Linux 普通用户执行 kubectl（root 会有一些问题）</p><p>我们为 普通用户(banban) 用户配置 kubectl：</p><pre><code>su - banbanmkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config</code></pre><p>为了使用更便捷，启用 kubectl 命令的自动补全功能</p><pre><code>echo &quot;source &lt;(kubectl completion bash)&quot; &gt;&gt; ~/.bashrc</code></pre><p>这样 banban 用户就可以使用 kubectl 了</p><h3 id="安装-Flannel-网络-Optional"><a href="#安装-Flannel-网络-Optional" class="headerlink" title="安装 Flannel 网络(Optional)"></a>安装 Flannel 网络(Optional)</h3><p>要让 Kubernetes Cluster 能够工作，必须安装 Pod 网络，否则 Pod 之间无法通信</p><p>Kubernetes 支持多种网络方案，这里我们先使用 flannel, flannel是一个 coreOS组织开源的项目, 这个组织做了很多在k8s上面的工作, 信息如下</p><p><a href="https://coreos.com/" target="_blank" rel="noopener">CoreOS</a></p><p><a href="https://github.com/coreos" target="_blank" rel="noopener">CoreOS github</a></p><p>执行如下命令部署 flannel</p><pre><code>kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</code></pre><p>由于这边直接使用的是master分支的yaml文件, 不能保证后续是否出现兼容性问题, 因此如果出现了问题可以使用下列tag下的yaml文件</p><pre><code>kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/v0.10.0/Documentation/kube-flannel.yml</code></pre><p>结果如下</p><pre><code>clusterrole.rbac.authorization.k8s.io/flannel createdclusterrolebinding.rbac.authorization.k8s.io/flannel createdserviceaccount/flannel createdconfigmap/kube-flannel-cfg createddaemonset.extensions/kube-flannel-ds-amd64 createddaemonset.extensions/kube-flannel-ds-arm64 createddaemonset.extensions/kube-flannel-ds-arm createddaemonset.extensions/kube-flannel-ds-ppc64le createddaemonset.extensions/kube-flannel-ds-s390x created</code></pre><h3 id="安装weave网络模型-Optional-和Flannel网络二选一"><a href="#安装weave网络模型-Optional-和Flannel网络二选一" class="headerlink" title="安装weave网络模型(Optional)(和Flannel网络二选一)"></a>安装weave网络模型(Optional)(和Flannel网络二选一)</h3><pre><code>sysctl net.bridge.bridge-nf-call-iptables=1</code></pre><p>Weave Net works on <code>amd64</code>, <code>arm</code>, <code>arm64</code> and <code>ppc64le</code> without any extra action required. Weave Net sets hairpin mode by default. This allows Pods to access themselves via their Service IP address if they don’t know their PodIP.</p><pre><code>kubectl apply -f &quot;https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d &#39;\n&#39;)&quot;</code></pre><h3 id="开启RBAC权限作为开发使用"><a href="#开启RBAC权限作为开发使用" class="headerlink" title="开启RBAC权限作为开发使用"></a>开启RBAC权限作为开发使用</h3><p><strong>Permissive RBAC Permissions</strong></p><p>You can replicate a permissive policy using RBAC role bindings.</p><p><em>==Warning: The following policy allows ALL service accounts to act as cluster administrators. Any application running in a container receives service account credentials automatically, and could perform any action against the API, including viewing secrets and modifying permissions. This is not a recommended policy.==</em></p><pre><code>kubectl create clusterrolebinding permissive-binding \--clusterrole=cluster-admin \--user=admin \--user=kubelet \--group=system:serviceaccounts</code></pre><pre><code>kubectl create clusterrolebinding add-on-cluster-admin \--clusterrole=cluster-admin \--serviceaccount=kube-system:default</code></pre><h3 id="添加-k8s-node1、k8s-node2"><a href="#添加-k8s-node1、k8s-node2" class="headerlink" title="添加 k8s-node1、k8s-node2"></a>添加 k8s-node1、k8s-node2</h3><p>在 k8s-node1、k8s-node2上执行如下命令，将其注册到 Cluster 中</p><pre><code>kubeadm join 10.82.45.41:6443 --token ylwv3f.n5iqf5mova5xm3nl --discovery-token-ca-cert-hash sha256:a3b77b9f9af801f9fa238a5e06db9a0dff37a159f1083ecf238042942b9a51b7</code></pre><p>这里的 –token 来自前面 kubeadm init 输出的第 ⑨ 步提示，如果当时没有记录下来可以通过 kubeadm token list 查看</p><p>执行结果</p><pre><code>[preflight] running pre-flight checks        [WARNING RequiredIPVSKernelModulesAvailable]: the IPVS proxier will not be used, because the following required kernel modules are not loaded: [ip_vs ip_vs_rr ip_vs_wrr ip_vs_sh] or no builtin kernel ipvs support: map[ip_vs:{} ip_vs_rr:{} ip_vs_wrr:{} ip_vs_sh:{} nf_conntrack_ipv4:{}]you can solve this problem with following methods: 1. Run &#39;modprobe -- &#39; to load missing kernel modules;2. Provide the missing builtin kernel ipvs support        [WARNING Service-Docker]: docker service is not enabled, please run &#39;systemctl enable docker.service&#39;I0711 10:56:53.967088    6978 kernel_validator.go:81] Validating kernel versionI0711 10:56:53.967522    6978 kernel_validator.go:96] Validating kernel config[discovery] Trying to connect to API Server &quot;192.168.18.129:6443&quot;[discovery] Created cluster-info discovery client, requesting info from &quot;https://192.168.18.129:6443&quot;[discovery] Requesting info from &quot;https://192.168.18.129:6443&quot; again to validate TLS against the pinned public key[discovery] Cluster info signature and contents are valid and TLS certificate validates against pinned roots, will use API Server &quot;192.168.18.129:6443&quot;[discovery] Successfully established connection with API Server &quot;192.168.18.129:6443&quot;[kubelet] Downloading configuration for the kubelet from the &quot;kubelet-config-1.11&quot; ConfigMap in the kube-system namespace[kubelet] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;[kubelet] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;[preflight] Activating the kubelet service[tlsbootstrap] Waiting for the kubelet to perform the TLS Bootstrap...[patchnode] Uploading the CRI Socket information &quot;/var/run/dockershim.sock&quot; to the Node API object &quot;banban-k8s-2&quot; as an annotationThis node has joined the cluster:* Certificate signing request was sent to master and a response  was received.* The Kubelet was informed of the new secure connection details.Run &#39;kubectl get nodes&#39; on the master to see this node join the cluster.</code></pre><p>为了能够在工作节点上执行kubectl命令,需要执行如下</p><pre><code>sudo cp /etc/kubernetes/kubelet.conf $HOME/sudo chown $(id -u):$(id -g) $HOME/kubelet.confexport KUBECONFIG=$HOME/kubelet.conf</code></pre><h3 id="启动一个简单demo"><a href="#启动一个简单demo" class="headerlink" title="启动一个简单demo"></a>启动一个简单demo</h3><ul><li><p>部署应用</p><pre><code>  kubectl run kubernetes-bootcamp \        --image=docker.io/jocatalin/kubernetes-bootcamp:v1 \        --port=8080</code></pre><p>  这里我们通过 kubectl run 部署了一个应用，命名为 kubernetes-bootcamp</p><p>  Docker 镜像通过 <code>--image</code> 指定</p><p>  <code>--port</code> 设置应用对外服务的端口</p><p>  输出结果如下</p><pre><code>  deployment.apps/kubernetes-bootcamp created</code></pre><p>  这里 deployment 是 Kubernetes 的术语，可以理解为应用</p><p>  <strong>Kubernetes 还有一个重要术语</strong> <code>Pod</code></p><p>  <code>Pod</code> 是容器的集合，通常会将紧密相关的一组容器放到一个 <code>Pod</code> 中，同一个 <code>Pod</code> 中的所有容器共享 IP 地址和 Port 空间，也就是说它们在一个 <code>network namespace</code> 中</p><p>  <code>Pod</code> 是 Kubernetes 调度的最小单位，同一 Pod 中的容器始终被一起调度</p><p>  运行 <code>kubectl get pods</code> 查看当前的 Pod</p></li><li><p>访问应用</p><p>  默认情况下，所有 Pod 只能在集群内部访问。对于上面这个例子，要访问应用只能直接访问容器的 8080 端口。为了能够从外部访问应用，我们需要将容器的 8080 端口映射到节点的端口。</p><p>  执行如下命令：</p><pre><code>  kubectl expose deployment/kubernetes-bootcamp \        --type=&quot;NodePort&quot; \        --port 8080</code></pre><p>  输出</p><pre><code>  service/kubernetes-bootcamp exposed</code></pre><p>  执行命令 kubectl get services 可以查看应用被映射到节点的哪个端口</p><pre><code>  kubectl get services </code></pre><pre><code>  NAME                  TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE  kubernetes            ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP          1h  kubernetes-bootcamp   NodePort    10.106.120.173   &lt;none&gt;        8080:31295/TCP   11s</code></pre><p>  查看这个服务对应的pod</p><pre><code>  kubectl get pods</code></pre><pre><code>  NAME                                   READY     STATUS    RESTARTS   AGE  kubernetes-bootcamp-86647cdf87-55msz   1/1       Running   0          1h</code></pre><p>  查看具体这个pod在哪一个node</p><pre><code>  kubectl describe pods kubernetes-bootcamp-86647cdf87-55msz</code></pre><pre><code>  Name:           kubernetes-bootcamp-86647cdf87-55msz  Namespace:      default  Node:           banban-k8s-2/192.168.18.130  Start Time:     Wed, 11 Jul 2018 13:07:33 +0800  Labels:         pod-template-hash=4220378943                  run=kubernetes-bootcamp  Annotations:    &lt;none&gt;  Status:         Running  IP:             10.244.1.6</code></pre><p>  因此外部访问服务可以通过</p><pre><code>  curl 192.168.18.130:31295</code></pre><pre><code>  Hello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-86647cdf87-55msz | v=1</code></pre></li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li><p><strong><em>kubeadm</em></strong></p><p>  node节点加入到集群中 </p><pre><code>  kubeadm join --token &lt;token1&gt; &lt;master-ip&gt;:6443</code></pre><p>  master节点查找认证token信息</p><pre><code>  kubeadm token list</code></pre><p>  重置配置</p><pre><code>  kubeadm reset</code></pre></li><li><p><strong><em>kubectl</em></strong></p><p>  获取nodes节点信息</p><pre><code>  kubectl get nodes</code></pre><p>  获取所有pod的信息</p><pre><code>  kubectl get pod --all-namespaces</code></pre><p>  获取pod信息及其具体在哪一node上</p><pre><code>  kubectl get pod --all-namespaces -o wide</code></pre><p>  获取某一个pod的具体信息</p><pre><code>  kubectl describe pod &lt;Pod Name&gt;</code></pre><p>  删除</p><pre><code>  kubectl delete -f &lt;file-name&gt;  kubectl delete pod &lt;pod-name&gt;  kubectl delete rc &lt;rc-name&gt;  kubectl delete service &lt;service-name&gt;  kubectl delete pod --all</code></pre><p>  出于安全考虑，默认配置下 Kubernetes 不会将 Pod 调度到 Master 节点。如果希望将 k8s-master 也当作 Node 使用，可以执行如下命令：</p><pre><code>  kubectl taint node &lt;k8s-master-name&gt; node-role.kubernetes.io/master-</code></pre><p>  如果要恢复 Master Only 状态，执行如下命令：</p><pre><code>  kubectl taint node &lt;k8s-master-name&gt; node-role.kubernetes.io/master=&quot;&quot;:NoSchedule</code></pre><p>  查看所有的pods发生的事件</p><pre><code>  kubectl get events</code></pre></li><li><p><strong><em>kubelet</em></strong></p><p>  kubelet 是唯一没有以容器形式运行的 Kubernetes 组件，它在 Ubuntu 中通过 Systemd 运行</p><pre><code>  systemctl status kubelet.service</code></pre><p>  查看kubelet是否正常启动,查看其健康状态</p><pre><code>  curl -L http://127.0.0.1:10250/healthz</code></pre></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Kubernetes安装过程中难免遇到很多问题，这边也许有些问题没有遇到，但是只要认真寻找解决方案就可以解决。目前Kubernete使用的网络是比较简单的flannel和wavenet，或许在之后的使用中会变更网络</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h2&gt;&lt;h3 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://banbanpeppa.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Hello Blog</title>
    <link href="https://banbanpeppa.github.io/2018/09/20/hello-world/hello-blog/"/>
    <id>https://banbanpeppa.github.io/2018/09/20/hello-world/hello-blog/</id>
    <published>2018-09-20T04:00:00.000Z</published>
    <updated>2018-09-21T11:41:16.757Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“我也开始写博客了. ”</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>折腾了好一会儿，banban 的 Blog 也算是开通了。</p><p>在选用这个模板之前，对比了很多Blog模板，最终是选择了两个模板，一个是<a href="https://github.com/Huxpro/huxpro.github.io" target="_blank" rel="noopener">Hux</a>，另一个是<a href="https://github.com/hmfaysal/Notepad" target="_blank" rel="noopener">Nodepad</a>。</p><p>当然了，我前端写的不多，不能自己撸一个漂亮的模板出来。</p><p>2018 年了，banban 总算装逼一个大佬程序员，有自己的 Blog 了，其实自己想拥有一个博客，主要也是因为自己在去网易游戏实习了两个月之后，接触了一些大牛，了解了大牛做技术的态度，也深深感受到，其实这么久了，自己好像都没有认认真真去对待做程序员这件事情，一直都在看别人的博客，有问题就Goolge，看别人的博客，自己的总结却很少。</p><p>后来开始自己也总结了，起初用了印象笔记，但是印象笔记编写就和写Word文件一样，很不友好，而一个博客在将来自己是否会倒回来看很多时候取决于排版是否优雅，看到印象里面不同的文字风格，是在是难受。</p><p>后来还是选择用markdown文件来编写文档，书写记录。很好写，于是就换了网易云笔记。但是，笔记共享出去 ———— 难看啊！真心难看。</p><p>实习的时候，由于做的项目和 <a href="https://github.com/kubeflow" target="_blank" rel="noopener">kubeflow</a> 相关，同时也了解到一位大牛 <a href="http://gaocegege.com/Blog/" target="_blank" rel="noopener">gaocegege</a>，他是 kubeflow 的 Maintainer ，很大牛，看看人家博客那么漂亮，心动了！意识到写博客是这么享受的一件事，就好像是一个程序员编写的秘籍，不管牛不牛逼，你自己真的觉得自己牛逼了一把！</p><p>那说什么呢！ 搞一个吧！</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>接下来说说搭建这个博客的技术细节。  </p><p>主要用了 <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> + <a href="http://jekyllrb.com/" target="_blank" rel="noopener">Jekyll</a> 快速 Building Blog 的技术方案，这个方案我看是目前来说很主流的做法了，当然 Hexo 也很多人用。</p><p>其优点非常明显：</p><ul><li><strong>Markdown</strong> 带来的优雅写作体验</li><li>非常熟悉的 Git workflow ，<strong>Git Commit 即 Blog Post</strong></li><li>利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机</li><li>如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了 </li><li>Jekyll 的自定制非常容易，基本就是个模版引擎</li></ul><p>安装Jekyll</p><pre><code>sudo apt-get install ruby ruby-dev build-essentialecho &#39;# Install Ruby Gems to ~/gems&#39; &gt;&gt; ~/.bashrcecho &#39;export GEM_HOME=$HOME/gems&#39; &gt;&gt; ~/.bashrcecho &#39;export PATH=$HOME/gems/bin:$PATH&#39; &gt;&gt; ~/.bashrcsource ~/.bashrcgem install jekyll bundlergem install pygments.rbgem install jekyll-paginate</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>有了自己的博客，怎么说都算是一个新的开始！未来在这里，记录一些琐事，当然更多是记录我学习的东西！</p><p>多写东西对自己也是锻炼。</p><p>有次问了下女朋友，你想要一个自己的网站吗？她说她不会也不想整。全当我在这也给你一片地，说不定你也想来说几句呢，2333333</p><p>—— banban 后记于 2018.09.20</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;“我也开始写博客了. ”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;折腾了好一会儿，banban 的 Blog 也
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://banbanpeppa.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
